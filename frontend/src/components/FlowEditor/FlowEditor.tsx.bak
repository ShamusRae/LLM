import React, { useCallback, useRef, useState, useMemo, useEffect } from 'react';
import ReactFlow, {
  Background,
  Controls,
  MiniMap,
  Panel,
  useReactFlow,
  Node,
  Edge,
  Connection,
  addEdge,
  NodeChange,
  EdgeChange,
  ConnectionMode,
  MarkerType,
  ReactFlowProvider,
} from 'reactflow';
import 'reactflow/dist/style.css';
import {
  Box,
  IconButton,
  Tooltip,
  Divider,
  Typography,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  TextField,
  Snackbar,
  Alert,
  CircularProgress,
  Paper,
} from '@mui/material';
import {
  Undo as UndoIcon,
  Redo as RedoIcon,
  Group as GroupIcon,
  CallSplit as UngroupIcon,
  ZoomIn as ZoomInIcon,
  ZoomOut as ZoomOutIcon,
  Save as SaveIcon,
  Download as DownloadIcon,
  Search as SearchIcon,
  ErrorOutline as ErrorIcon,
} from '@mui/icons-material';
import { useAppDispatch, useAppSelector } from '../../store/hooks';
import {
  setNodes,
  setEdges,
  addNode,
  updateNode,
  removeNode,
  addEdge as addFlowEdge,
  removeEdge,
  undo,
  redo,
  loadFlow,
  clearFlow,
  markAsSaved,
  groupNodes,
  ungroupNodes,
} from '../../store/flowSlice';
import { useKeyboardShortcuts } from '../../hooks/useKeyboardShortcuts';
import { Asset } from './AssetPalette';
import { flowService } from '../../services/flowService';
import QuickBooksNode, { QuickBooksNodeData } from './CustomNodes/QuickBooksNode';
import GroupNode, { GroupNodeData } from './CustomNodes/GroupNode';
import ErrorBoundary from '../ErrorBoundary/ErrorBoundary';

// Node types
const nodeTypes = {
  quickbooks: QuickBooksNode,
  group: GroupNode,
};

// Error boundary fallback component
const FlowEditorFallback = ({ error, resetErrorBoundary }: { error: Error; resetErrorBoundary: () => void }) => (
  <Paper 
    elevation={0}
    sx={{
      p: 3,
      height: '100%',
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      justifyContent: 'center',
      gap: 2,
    }}
  >
    <ErrorIcon color="error" sx={{ fontSize: 64 }} />
    <Typography variant="h5" color="error" gutterBottom>
      Something went wrong in the Flow Editor
    </Typography>
    <Typography variant="body1" color="text.secondary" gutterBottom align="center" sx={{ maxWidth: 600 }}>
      {error.message}
    </Typography>
    <Button variant="contained" onClick={resetErrorBoundary} startIcon={<span>ðŸ”„</span>}>
      Reset Editor
    </Button>
  </Paper>
);

const FlowEditorWithoutProvider: React.FC = () => {
  const dispatch = useAppDispatch();
  const { nodes, edges, isModified } = useAppSelector((state) => state.flow);
  const reactFlowWrapper = useRef<HTMLDivElement>(null);
  const [searchQuery, setSearchQuery] = useState("");
  const [searchResults, setSearchResults] = useState<string[]>([]);
  const [isSearchOpen, setIsSearchOpen] = useState(false);
  const [isSaveDialogOpen, setIsSaveDialogOpen] = useState(false);
  const [flowName, setFlowName] = useState('');
  const [flowDescription, setFlowDescription] = useState('');
  const [isSaving, setIsSaving] = useState(false);
  const [isGroupDialogOpen, setIsGroupDialogOpen] = useState(false);
  const [groupName, setGroupName] = useState('Group');
  const [snackbar, setSnackbar] = useState<{
    open: boolean;
    message: string;
    severity: 'success' | 'error' | 'info' | 'warning';
  }>({
    open: false,
    message: '',
    severity: 'info',
  });

  const { project, fitView, zoomIn, zoomOut, getNode, getNodes } = useReactFlow();

  // Edge validation rules
  const isValidConnection = useCallback((connection: Connection) => {
    // Check if we're not connecting a node to itself
    if (connection.source === connection.target) {
      return false;
    }

    // Get source and target nodes
    const sourceNode = nodes.find(node => node.id === connection.source);
    const targetNode = nodes.find(node => node.id === connection.target);

    if (!sourceNode || !targetNode) {
      return false;
    }

    // Check if there's already a connection between these nodes
    const existingEdge = edges.find(
      edge => edge.source === connection.source && edge.target === connection.target
    );

    if (existingEdge) {
      return false;
    }

    // Add more validation rules as needed for specific node types
    if (sourceNode.type === 'quickbooks' && targetNode.type === 'quickbooks') {
      // Check specific QuickBooks node connection rules
      // For example, validate source.data.apiPermissions include what target node needs
      const sourceData = sourceNode.data as QuickBooksNodeData;
      const targetData = targetNode.data as QuickBooksNodeData;
      
      // Example validation: source must have API permissions that target requires
      return true; // Simplified for now
    }

    return true;
  }, [nodes, edges]);

  // Handle node changes
  const handleNodesChange = useCallback((changes: NodeChange[]) => {
    const updatedNodes = [...nodes];
    
    for (const change of changes) {
      if (change.type === 'remove') {
        dispatch(removeNode(change.id));
        return; // Let Redux handle node removal and associated edges
      }
    }
    
    // For position and selection changes, update through setNodes
    dispatch(setNodes(
      updatedNodes.map(node => {
        const change = changes.find(c => {
          if ('id' in c) {
            return c.id === node.id;
          }
          return false;
        });
        if (change?.type === 'position' && 'position' in change && change.position) {
          return { ...node, position: change.position };
        }
        if (change?.type === 'select') {
          return { ...node, selected: change.selected };
        }
        return node;
      })
    ));
  }, [dispatch, nodes]);

  // Handle edge changes
  const handleEdgesChange = useCallback((changes: EdgeChange[]) => {
    const updatedEdges = [...edges];
    
    for (const change of changes) {
      if (change.type === 'remove') {
        dispatch(removeEdge(change.id));
        return; // Let Redux handle edge removal
      }
    }
    
    // For selection changes, update through setEdges
    dispatch(setEdges(
      updatedEdges.map(edge => {
        const change = changes.find(c => {
          if ('id' in c) {
            return c.id === edge.id;
          }
          return false;
        });
        if (change?.type === 'select') {
          return { ...edge, selected: change.selected };
        }
        return edge;
      })
    ));
  }, [dispatch, edges]);

  // Handle connections
  const handleConnect = useCallback((connection: Connection) => {
    if (!isValidConnection(connection)) {
      setSnackbar({
        open: true,
        message: 'Invalid connection. Please check node compatibility.',
        severity: 'warning',
      });
      return;
    }

    const newEdge = {
      ...connection,
      id: `e${connection.source}-${connection.target}`,
      markerEnd: { type: MarkerType.ArrowClosed },
      type: 'default',
    };
    
    dispatch(addFlowEdge(newEdge as Edge));
  }, [dispatch, isValidConnection]);

  // DnD handling
  const onDrop = useCallback(
    (event: React.DragEvent<HTMLDivElement>) => {
      event.preventDefault();

      if (!reactFlowWrapper.current) return;

      const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();
      const assetData = event.dataTransfer.getData('application/json');
      
      if (!assetData) return;
      
      try {
        const asset = JSON.parse(assetData) as Asset;
        const position = project({
          x: event.clientX - reactFlowBounds.left,
          y: event.clientY - reactFlowBounds.top,
        });

        let nodeType = 'default';
        let nodeData: any = { label: asset.name };

        // Determine node type and data based on asset type
        if (asset.id === 'quickbooks') {
          nodeType = 'quickbooks';
          nodeData = {
            label: asset.name,
            apiKey: '',
            permissions: 'readonly',
            dataTables: [],
          };
        }

        const newNode = {
          id: `node-${Date.now()}`,
          type: nodeType,
          position,
          data: nodeData,
        };

        dispatch(addNode(newNode as Node));
      } catch (error) {
        console.error('Error adding new node:', error);
        setSnackbar({
          open: true,
          message: 'Failed to add node. Invalid asset data.',
          severity: 'error',
        });
      }
    },
    [project, dispatch]
  );

  const onDragOver = useCallback((event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  // Keyboard shortcuts
  useKeyboardShortcuts({
    'mod+z': () => dispatch(undo()),
    'mod+y': () => dispatch(redo()),
    'mod+shift+z': () => dispatch(redo()),
    'mod+s': () => setIsSaveDialogOpen(true),
    'mod+g': () => handleOpenGroupDialog(),
    'delete': () => {
      const selectedNodes = nodes.filter(node => node.selected);
      const selectedEdges = edges.filter(edge => edge.selected);
      
      selectedEdges.forEach(edge => dispatch(removeEdge(edge.id)));
      selectedNodes.forEach(node => dispatch(removeNode(node.id)));
    },
  });

  // Group/Ungroup functionality
  const handleOpenGroupDialog = useCallback(() => {
    // Check if there are at least 2 selected nodes
    const selectedNodes = nodes.filter(node => node.selected);
    if (selectedNodes.length < 2) {
      setSnackbar({
        open: true,
        message: 'Select at least 2 nodes to group',
        severity: 'warning',
      });
      return;
    }
    
    setGroupName('Group');
    setIsGroupDialogOpen(true);
  }, [nodes]);

  const handleGroupNodes = useCallback(() => {
    const selectedNodes = nodes.filter(node => node.selected);
    if (selectedNodes.length < 2) {
      setSnackbar({
        open: true,
        message: 'Select at least 2 nodes to group',
        severity: 'warning',
      });
      return;
    }

    // Calculate the center position of selected nodes
    const positions = selectedNodes.map(node => node.position);
    const minX = Math.min(...positions.map(p => p.x));
    const minY = Math.min(...positions.map(p => p.y));
    
    // Get node dimensions (use default values if not specified)
    const nodeWidths = selectedNodes.map(node => (node.width || 150));
    const nodeHeights = selectedNodes.map(node => (node.height || 40));
    
    // Calculate max extents
    const maxX = Math.max(...positions.map((p, i) => p.x + nodeWidths[i]));
    const maxY = Math.max(...positions.map((p, i) => p.y + nodeHeights[i]));
    
    // Position the group node at the top-left corner of the selection
    const position = { x: minX - 20, y: minY - 20 };
    
    // Create a group with the selected nodes
    dispatch(groupNodes({
      nodeIds: selectedNodes.map(node => node.id),
      position,
      groupName,
    }));
    
    setIsGroupDialogOpen(false);
    
    setSnackbar({
      open: true,
      message: 'Nodes grouped successfully',
      severity: 'success',
    });
  }, [nodes, groupName, dispatch]);

  const handleUngroupNodes = useCallback(() => {
    // Find selected group nodes
    const selectedGroupNodes = nodes.filter(node => node.selected && node.type === 'group');
    
    if (selectedGroupNodes.length === 0) {
      setSnackbar({
        open: true,
        message: 'Select a group to ungroup',
        severity: 'warning',
      });
      return;
    }
    
    // Ungroup each selected group
    selectedGroupNodes.forEach(node => {
      dispatch(ungroupNodes(node.id));
    });
    
    setSnackbar({
      open: true,
      message: 'Nodes ungrouped successfully',
      severity: 'success',
    });
  }, [nodes, dispatch]);

  // Search functionality
  useEffect(() => {
    if (!searchQuery) {
      setSearchResults([]);
      return;
    }
    
    const lowerQuery = searchQuery.toLowerCase();
    const matchingNodes = nodes.filter(node => 
      node.data.label?.toLowerCase().includes(lowerQuery)
    ).map(node => node.id);
    
    setSearchResults(matchingNodes);
  }, [searchQuery, nodes]);

  const handleSearch = () => {
    setIsSearchOpen(!isSearchOpen);
    if (!isSearchOpen) {
      setSearchQuery('');
      setSearchResults([]);
    }
  };

  const handleSearchNodeClick = (nodeId: string) => {
    const node = getNode(nodeId);
    if (node) {
      fitView({ nodes: [node], duration: 800, padding: 0.2 });
    }
  };

  // Flow export functionality 
  const handleExportFlow = useCallback(() => {
    const flowData = {
      nodes,
      edges,
      name: 'Exported Flow',
      description: 'Flow exported from Flow Editor',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    try {
      const jsonString = JSON.stringify(flowData, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `flow-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      setSnackbar({
        open: true,
        message: 'Flow exported successfully',
        severity: 'success',
      });
    } catch (error) {
      console.error('Error exporting flow:', error);
      setSnackbar({
        open: true,
        message: 'Failed to export flow. Please try again.',
        severity: 'error',
      });
    }
  }, [nodes, edges]);

  // Save flow functionality
  const handleSaveFlow = useCallback(async () => {
    if (!flowName.trim()) {
      return;
    }

    setIsSaving(true);
    try {
      const flowData = {
        nodes,
        edges,
        name: flowName,
        description: flowDescription,
      };

      await flowService.saveFlow(flowData);
      dispatch(markAsSaved());
      
      setSnackbar({
        open: true,
        message: 'Flow saved successfully',
        severity: 'success',
      });
      setIsSaveDialogOpen(false);
      setFlowName('');
      setFlowDescription('');
    } catch (error) {
      console.error('Failed to save flow:', error);
      setSnackbar({
        open: true,
        message: 'Failed to save flow. Please try again.',
        severity: 'error',
      });
    } finally {
      setIsSaving(false);
    }
  }, [nodes, edges, flowName, flowDescription, dispatch]);

  // Snackbar close handler
  const handleCloseSnackbar = () => {
    setSnackbar(prev => ({ ...prev, open: false }));
  };

  // React Flow instance ready handler
  const onInit = useCallback(() => {
    setTimeout(() => {
      fitView({ padding: 0.2 });
    }, 100);
  }, [fitView]);

  // Filtered nodes for search
  const filteredNodes = useMemo(() => {
    if (!searchQuery) return nodes;
    return nodes.map(node => ({
      ...node,
      highlighted: searchResults.includes(node.id),
    }));
  }, [nodes, searchQuery, searchResults]);

  // Reset error handler for error boundary
  const handleResetError = useCallback(() => {
    dispatch(clearFlow());
    fitView();
  }, [dispatch, fitView]);

  return (
    <ErrorBoundary 
      FallbackComponent={FlowEditorFallback} 
      onReset={handleResetError}
    >
      <Box
        ref={reactFlowWrapper}
        sx={{
          width: '100%',
          height: '100%',
          position: 'relative',
        }}
      >
        <ReactFlow
          nodes={filteredNodes}
          edges={edges}
          onNodesChange={handleNodesChange}
          onEdgesChange={handleEdgesChange}
          onConnect={handleConnect}
          onInit={onInit}
          nodeTypes={nodeTypes}
          onDrop={onDrop}
          onDragOver={onDragOver}
          connectionMode={ConnectionMode.Loose}
          fitView
        >
          <Background />
          <Controls />
          <MiniMap style={{ height: 120 }} zoomable pannable />
          
          {/* Control Panel */}
          <Panel position="top-right">
            <Paper
              elevation={0}
              sx={{
                p: 1,
                display: 'flex',
                flexDirection: 'column',
                gap: 1,
                border: '1px solid',
                borderColor: 'divider',
                borderRadius: 1,
              }}
            >
              {/* Undo/Redo */}
              <Box sx={{ display: 'flex', gap: 0.5 }}>
                <Tooltip title="Undo (Ctrl+Z)">
                  <IconButton
                    size="small"
                    onClick={() => dispatch(undo())}
                  >
                    <UndoIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
                <Tooltip title="Redo (Ctrl+Y)">
                  <IconButton
                    size="small"
                    onClick={() => dispatch(redo())}
                  >
                    <RedoIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
              </Box>
              
              <Divider />
              
              {/* Zoom controls */}
              <Box sx={{ display: 'flex', gap: 0.5 }}>
                <Tooltip title="Zoom In">
                  <IconButton
                    size="small"
                    onClick={() => zoomIn()}
                  >
                    <ZoomInIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
                <Tooltip title="Zoom Out">
                  <IconButton
                    size="small"
                    onClick={() => zoomOut()}
                  >
                    <ZoomOutIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
              </Box>
              
              <Divider />
              
              {/* Group/Ungroup */}
              <Box sx={{ display: 'flex', gap: 0.5 }}>
                <Tooltip title="Group Nodes (Ctrl+G)">
                  <IconButton
                    size="small"
                    onClick={handleOpenGroupDialog}
                  >
                    <GroupIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
                <Tooltip title="Ungroup Nodes">
                  <IconButton
                    size="small"
                    onClick={handleUngroupNodes}
                  >
                    <UngroupIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
              </Box>
              
              <Divider />
              
              {/* Search */}
              <Box sx={{ display: 'flex', gap: 0.5 }}>
                <Tooltip title="Search Nodes">
                  <IconButton
                    size="small"
                    onClick={handleSearch}
                    color={isSearchOpen ? 'primary' : 'default'}
                  >
                    <SearchIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
              </Box>
              
              <Divider />
              
              {/* Save & Export */}
              <Box sx={{ display: 'flex', gap: 0.5 }}>
                <Tooltip title="Save Flow (Ctrl+S)">
                  <IconButton
                    size="small"
                    onClick={() => setIsSaveDialogOpen(true)}
                    color={isModified ? 'primary' : 'default'}
                  >
                    <SaveIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
                <Tooltip title="Export Flow">
                  <IconButton
                    size="small"
                    onClick={handleExportFlow}
                  >
                    <DownloadIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
              </Box>
            </Paper>
          </Panel>
          
          {/* Search Panel */}
          {isSearchOpen && (
            <Panel position="top-left">
              <Paper
                elevation={0}
                sx={{
                  p: 1,
                  display: 'flex',
                  flexDirection: 'column',
                  gap: 1,
                  border: '1px solid',
                  borderColor: 'divider',
                  borderRadius: 1,
                  width: 250,
                }}
              >
                <TextField
                  size="small"
                  placeholder="Search nodes..."
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  autoFocus
                  fullWidth
                />
                {searchResults.length > 0 && (
                  <Box sx={{ maxHeight: 200, overflow: 'auto' }}>
                    {searchResults.map((nodeId) => {
                      const node = nodes.find((n) => n.id === nodeId);
                      return (
                        <Box
                          key={nodeId}
                          onClick={() => handleSearchNodeClick(nodeId)}
                          sx={{
                            py: 0.5,
                            px: 1,
                            cursor: 'pointer',
                            '&:hover': {
                              backgroundColor: 'action.hover',
                            },
                            borderRadius: 1,
                          }}
                        >
                          <Typography variant="body2">
                            {node?.data?.label || nodeId}
                          </Typography>
                        </Box>
                      );
                    })}
                  </Box>
                )}
              </Paper>
            </Panel>
          )}
        </ReactFlow>

        {/* Save Flow Dialog */}
        <Dialog open={isSaveDialogOpen} onClose={() => setIsSaveDialogOpen(false)}>
          <DialogTitle>Save Flow</DialogTitle>
          <DialogContent>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 2 }}>
              <TextField
                fullWidth
                label="Flow Name"
                value={flowName}
                onChange={(e) => setFlowName(e.target.value)}
                required
                disabled={isSaving}
              />
              <TextField
                fullWidth
                label="Description"
                value={flowDescription}
                onChange={(e) => setFlowDescription(e.target.value)}
                multiline
                rows={3}
                disabled={isSaving}
              />
            </Box>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setIsSaveDialogOpen(false)} disabled={isSaving}>
              Cancel
            </Button>
            <Button
              onClick={handleSaveFlow}
              variant="contained"
              color="primary"
              disabled={!flowName.trim() || isSaving}
            >
              {isSaving ? (
                <>
                  <CircularProgress size={20} sx={{ mr: 1 }} />
                  Saving...
                </>
              ) : (
                'Save'
              )}
            </Button>
          </DialogActions>
        </Dialog>

        {/* Group Nodes Dialog */}
        <Dialog open={isGroupDialogOpen} onClose={() => setIsGroupDialogOpen(false)}>
          <DialogTitle>Group Nodes</DialogTitle>
          <DialogContent>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 2 }}>
              <TextField
                fullWidth
                label="Group Name"
                value={groupName}
                onChange={(e) => setGroupName(e.target.value)}
                autoFocus
              />
            </Box>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setIsGroupDialogOpen(false)}>
              Cancel
            </Button>
            <Button
              onClick={handleGroupNodes}
              variant="contained"
              color="primary"
            >
              Group
            </Button>
          </DialogActions>
        </Dialog>

        {/* Snackbar for notifications */}
        <Snackbar
          open={snackbar.open}
          autoHideDuration={6000}
          onClose={handleCloseSnackbar}
          anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
        >
          <Alert
            onClose={handleCloseSnackbar}
            severity={snackbar.severity}
            sx={{ width: '100%' }}
          >
            {snackbar.message}
          </Alert>
        </Snackbar>
      </Box>
    </ErrorBoundary>
  );
};

// Wrap the component with ReactFlowProvider
const FlowEditor: React.FC = () => {
  return (
    <ReactFlowProvider>
      <FlowEditorWithoutProvider />
    </ReactFlowProvider>
  );
};

export default FlowEditor; 